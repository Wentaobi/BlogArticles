## [TCP收发怎么解决同步的问题](https://bbs.csdn.net/topics/392045835)
[推荐] TCP收发怎么解决同步的问题 [问题点数：20分，结帖人xiaoyuanyuan2009]
https://bbs.csdn.net/topics/392045835

我现在是电脑和安卓手机在局域网内收发信息，收发的内容是数据库表的字段。
电脑的代码是连续4个发送，手机的代码是4个连续的接收。那么问题来了，由于速度差异，电脑发送了3个之后，手机才开始第一次调用接收。这样手机就可能在第一次接收时把3个字段接收到第一个缓冲区去。
求个解决思路！

自定义数据包结构。
一般为 包头(数据长度、标记位之类的) + 数据内容。
接收方接收到数据包，拆包，看这个数据长度有多少，就读取多少，不够继续等到够再处理。

TCP连接有个选项no_delay选项，用于禁用Nagle算法的拼包，需要即时响应速度的应用都需要加这个。
当初设计是用来减少包头占用，提高整体传输效率的。

参考http://blog.csdn.net/shaobingj126/article/details/6758707

你这么想是没有必要的。
你仔细看看大家的回答，答案都是一样的。
想过为什么吗？
因为有几点是你没想到的：
1.TCP协议保证会把客户端发送的一定会发过来
2.服务端收数据时，可以设置超时。超时没收到，就结束自己读数据的线程就行了。
所以你只要用byte[4]读四个字节，然后解码这4字节为long，
然后用这long值读后续数据即可。
至于读后续数据，用一个固定长度的bytes，比如byte[256]或byte[8192]去读即可。
你或许会问，万一long值大于8192呢？
答案是多读几次直到达到long值的数据。
如果以上条件不满足，超时就结束自己线程，这样就行了。
其他的，交给客户端去配合。
任何原因的不配合，比如客户端不按规则玩，或者网络断了，或者任何我们没料到的，
超时就结束自己线程，这样就行了。

剩余的，你不要坐在这里钻牛角尖的乱想，你多写几个例子，就明白了。
对了。补充一句
除了“数据长度+数据"这个方案外，
还有一个方案是用分隔符（比如0x13）分段，
SMTP, POP3或http（事实上它两种方案都支持）协议都用这个方案。
发送端会不会一次发不完，如果只发了一部分的时候，接收端是不是就已经可以读取了，接收端是不是要等发送端全部发送完毕以后在读取？

这个问题叫粘包问题，是tcp开发中非常常见的问题，但是国内的技术资料中都对此语焉不详。解决方法就是上面有人提到的自定义协议头，并在协议头中发送长度，只有接收到了足够的长度的数据后才转入业务逻辑处理层。

你这个是数据粘包哇。
你应该定义通信的报文，也就是你的应用协议
比如报文：****message####
****就是包头
####就是包尾
比如你发了如下数据给客户端：
****1234567####****1234567####****1234567####****1234567####
客户端一次一次的读取数据：
第一次读取到数据：****1234567####****1234（此时读取到了一包半的数据，粘包了，你得拆）
第二次读取到数据：567####****123
第三次读取到数据：4567####****1234567####
你得把接收到的数据按照你定义的报文****message####来拆分
比如第一次读取的数据：首先将完整包****1234567####取出来，剩下的****1234放在缓存中，等待第二次出去数据，把剩下数据和第二次的数据合并****1234567####****123，然后在拆，当然这是最笨的方法，这里可以优化的，但是意思大概就是这个意思
